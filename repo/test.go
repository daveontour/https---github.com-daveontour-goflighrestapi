package repo

import (
	"context"
	"fmt"
	"log"
	"math/rand"
	"os"
	"path/filepath"
	"strings"
	"time"

	"flightresourcerestapi/globals"
	"flightresourcerestapi/models"
	"flightresourcerestapi/timeservice"

	amqp "github.com/rabbitmq/amqp091-go"
	"github.com/spf13/viper"
)

const standslottemplate = `<StandSlots>
<StandSlot>
  <Value propertyName="StartTime">%s</Value>
  <Value propertyName="EndTime">%s</Value>
  <Stand>
    <Value propertyName="Name">%s</Value>
    <Value propertyName="ExternalName">%s</Value>
    <Area>
      <Value propertyName="Name">%s</Value>
    </Area>
  </Stand>
</StandSlot>
</StandSlots>`

const checkinslotstemplate = `
<CheckInSlots>
<CheckInSlot>
  <Value propertyName="StartTime">%[1]s</Value>
  <Value propertyName="EndTime">%[2]s</Value>
  <Value propertyName="Category">Economy</Value>
  <CheckIn>
    <Value propertyName="Name">%[3]s%[4]d</Value>
    <Value propertyName="ExternalName">%[3]s%[4]d</Value>
    <Area>
      <Value propertyName="Name">%[3]s</Value>
    </Area>
  </CheckIn>
</CheckInSlot>
<CheckInSlot>
  <Value propertyName="StartTime">%[1]s</Value>
  <Value propertyName="EndTime">%[2]s</Value>
  <Value propertyName="Category">Economy</Value>
  <CheckIn>
    <Value propertyName="Name">%[3]s%[5]d</Value>
    <Value propertyName="ExternalName">%[3]s%[5]d</Value>
    <Area>
      <Value propertyName="Name">%[3]s</Value>
    </Area>
  </CheckIn>
</CheckInSlot>
<CheckInSlot>
<Value propertyName="StartTime">%[1]s</Value>
<Value propertyName="EndTime">%[2]s</Value>
  <Value propertyName="Category">Economy</Value>
  <CheckIn>
    <Value propertyName="Name">%[3]s%[6]d</Value>
    <Value propertyName="ExternalName">%[3]s%[6]d</Value>
    <Area>
      <Value propertyName="Name">%[3]s</Value>
    </Area>
  </CheckIn>
</CheckInSlot>
<CheckInSlot>
<Value propertyName="StartTime">%[1]s</Value>
<Value propertyName="EndTime">%[2]s</Value>
  <Value propertyName="Category">Economy</Value>
  <CheckIn>
    <Value propertyName="Name">%[3]s%[7]d</Value>
    <Value propertyName="ExternalName">%[3]s%[7]d</Value>
    <Area>
      <Value propertyName="Name">%[3]s</Value>
    </Area>
  </CheckIn>
</CheckInSlot>
</CheckInSlots>
`
const gateslotstemplate = `
<GateSlots>
<GateSlot>
  <Value propertyName="StartTime">%s</Value>
  <Value propertyName="EndTime">%s</Value>
  <Value propertyName="Category">departure</Value>
  <Gate>
    <Value propertyName="Name">%s</Value>
    <Value propertyName="ExternalName">%s</Value>
    <Area>
      <Value propertyName="Name">%s</Value>
    </Area>
  </Gate>
</GateSlot>
</GateSlots>
`

const carouselslotstemplate = `
<CarouselSlots>
<CarouselSlot>
  <Value propertyName="StartTime">%s</Value>
  <Value propertyName="EndTime">%s</Value>
  <Value propertyName="Category" />
  <Carousel>
    <Value propertyName="Name">%s</Value>
    <Value propertyName="ExternalName">%s</Value>
    <Area>
      <Value propertyName="Name">%s</Value>
    </Area>
  </Carousel>
</CarouselSlot>
</CarouselSlots>
`

type AutoGenerated struct {
	TestConfig struct {
		Repository   models.Repository `json:"Repository"`
		CheckinAreas []struct {
			Area   string `json:"Area"`
			Number int    `json:"Number"`
		} `json:"CheckinAreas"`
		GateAreas []struct {
			Area   string `json:"Area"`
			Number int    `json:"Number"`
		} `json:"GateAreas"`
		StandAreas []struct {
			Area   string `json:"Area"`
			Number int    `json:"Number"`
		} `json:"StandAreas"`
		CarouselAreas []struct {
			Area   string `json:"Area"`
			Number int    `json:"Number"`
		} `json:"CarouselAreas"`
		ChuteAreas []struct {
			Area   string `json:"Area"`
			Number int    `json:"Number"`
		} `json:"ChuteAreas"`
		Airlines []string `json:"Airlines"`
		Routes   []string `json:"Routes"`
	} `json:"TestConfig"`
}

var testInit = false

func PerfTestInit(nf int, minProperties int) {

	if testInit {
		fmt.Println("Test Repo has already been initialised")
		return
	}
	testInit = true
	exe, err0 := os.Executable()
	if err0 != nil {
		panic(err0)
	}
	exPath := filepath.Dir(exe)
	testViper := viper.New()

	testViper.SetConfigName("test") // name of config file (without extension)
	testViper.SetConfigType("json") // REQUIRED if the config file does not have the extension in the name
	testViper.AddConfigPath(".")    // optionally look for config in the working directory
	testViper.AddConfigPath(exPath)
	if err := testViper.ReadInConfig(); err != nil {
		globals.Logger.Fatal("Could Not Read test.json config file")
	}

	var config = AutoGenerated{}
	if err := testViper.Unmarshal(&config); err != nil {
		fmt.Println("Error reading test config file")
		return
	}

	globals.RepoList = append(globals.RepoList, config.TestConfig.Repository)

	rep := GetRepo(config.TestConfig.Repository.AMSAirport)

	for _, ci := range config.TestConfig.CheckinAreas {
		addResource(ci.Area, ci.Number, "CheckIn", &rep.CheckInList)
	}
	for _, ci := range config.TestConfig.GateAreas {
		addResource(ci.Area, ci.Number, "Gate", &rep.GateList)
	}
	for _, ci := range config.TestConfig.StandAreas {
		addResource(ci.Area, ci.Number, "Stand", &rep.StandList)
	}
	for _, ci := range config.TestConfig.CarouselAreas {
		addResource(ci.Area, ci.Number, "Carousel", &rep.CarouselList)
	}
	for _, ci := range config.TestConfig.ChuteAreas {
		addResource(ci.Area, ci.Number, "Chute", &rep.ChuteList)
	}

	// If it's not demo mode then init the repoManager to listen on Rabbit MQ
	if !globals.DemoMode {
		go MaintainRepository(config.TestConfig.Repository.AMSAirport, true)
		time.Sleep(time.Duration(1 * time.Second))
	}

	SendFlightMessages(nf)
	rep.MinimumProperties(minProperties)

}
func SendUpdateMessages(nf int) {
	SendFlightMessages(nf)
}

func addResource(area string, num int, rtype string, arr *models.ResourceLinkedList) {

	for i := 1; i <= num; i++ {
		arr.AddNode(
			models.ResourceAllocationStruct{
				Resource: models.FixedResource{
					ResourceTypeCode: rtype,
					Name:             fmt.Sprintf("%s%d", area, i),
					Area:             area,
				},
			},
		)
	}

}

var testConfig AutoGenerated

func SendFlightMessages(nf int) {

	exe, err0 := os.Executable()
	if err0 != nil {
		panic(err0)
	}
	exPath := filepath.Dir(exe)
	testViper := viper.New()

	testViper.SetConfigName("test") // name of config file (without extension)
	testViper.SetConfigType("json") // REQUIRED if the config file does not have the extension in the name
	testViper.AddConfigPath(".")    // optionally look for config in the working directory
	testViper.AddConfigPath(exPath)
	if err := testViper.ReadInConfig(); err != nil {
		globals.Logger.Fatal("Could Not Read test.json config file")
	}

	if err := testViper.Unmarshal(&testConfig); err != nil {
		fmt.Println("Error reading test config file")
		return
	}
	t := time.Now()

	fileContent, err := os.ReadFile("arrival.template.xml")
	if err != nil {
		log.Fatal(err)
	}
	arrFlightUpdateBody := string(fileContent)

	fileContent, err = os.ReadFile("departure.template.xml")
	if err != nil {
		log.Fatal(err)
	}
	depFlightUpdateBody := string(fileContent)

	for i := 0; i < nf; i = i + 2 {

		al := testConfig.TestConfig.Airlines[i%len(testConfig.TestConfig.Airlines)]
		route := testConfig.TestConfig.Routes[i%len(testConfig.TestConfig.Routes)]
		arrivalFlightNumber := 1 + i
		departureFlightNumber := arrivalFlightNumber + 1

		departureSTO := time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, t.Location())
		departureSTO = departureSTO.Add(time.Minute * time.Duration(i))

		checkInOpenTime := departureSTO.Add(time.Minute * time.Duration(-1*180))
		checkInOpenTimeString := checkInOpenTime.Format(timeservice.Layout)
		checkInCloseTime := checkInOpenTime.Add(time.Minute * time.Duration(135))
		checkInClosrTimeString := checkInCloseTime.Format(timeservice.Layout)

		departureGateOpenTime := departureSTO.Add(time.Minute * time.Duration(-1*60))
		departureGateOpenTimeString := departureGateOpenTime.Format(timeservice.Layout)

		arrivalSTO := departureSTO.Add(time.Minute * time.Duration(-1*125))
		arrivalSTOString := arrivalSTO.Format(timeservice.Layout)

		arrivalGateCloseTime := arrivalSTO.Add(time.Minute * time.Duration(30))
		arrGateCloseTimeString := arrivalGateCloseTime.Format(timeservice.Layout)

		arrivalCarouselOpenTime := arrivalSTO.Add(time.Minute * time.Duration(15))
		// carouselst := carouselopen.Format(timeservice.Layout)

		arrivalCarouselCloseTime := arrivalCarouselOpenTime.Add(time.Minute * time.Duration(60))
		arrivalCarouselCloseTimeString := arrivalCarouselCloseTime.Format(timeservice.Layout)

		standOpenTime := arrivalSTO.Add(time.Minute * time.Duration(-15))
		standOpenTimeString := standOpenTime.Format(timeservice.Layout)

		standCloseTime := departureSTO.Add(time.Minute * time.Duration(15))
		standCloseTimeString := standCloseTime.Format(timeservice.Layout)

		gateArea := testConfig.TestConfig.GateAreas[i%len(testConfig.TestConfig.GateAreas)]
		standArea := testConfig.TestConfig.StandAreas[i%len(testConfig.TestConfig.StandAreas)]
		// chuteArea := config.TestConfig.ChuteAreas[i%len(config.TestConfig.ChuteAreas)]
		carouselArea := testConfig.TestConfig.CarouselAreas[i%len(testConfig.TestConfig.CarouselAreas)]
		checkinArea := testConfig.TestConfig.CheckinAreas[i%len(testConfig.TestConfig.CheckinAreas)]

		gateNum := rand.Intn(gateArea.Number) + 1
		standNum := rand.Intn(standArea.Number) + 1
		// chuteNum := rand.Intn(chuteArea.Number)+1
		carouselNum := rand.Intn(carouselArea.Number) + 1
		checkinNum := rand.Intn(checkinArea.Number-4) + 1

		arrivalSDOString := arrivalSTO.Format("2006-01-02")
		departureSTOString := departureSTO.Format(timeservice.Layout)
		departureSDOString := departureSTO.Format("2006-01-02")
		registration := fmt.Sprintf("VH-%d", i)

		checkinslot := fmt.Sprintf(checkinslotstemplate,
			checkInOpenTimeString,
			checkInClosrTimeString,
			checkinArea.Area,
			checkinNum,
			checkinNum+1,
			checkinNum+2,
			checkinNum+3)

		standslot := fmt.Sprintf(standslottemplate,
			standOpenTimeString,
			standCloseTimeString,
			fmt.Sprintf("%s%d", standArea.Area, standNum),
			fmt.Sprintf("%s%d", standArea.Area, standNum),
			standArea.Area)

		gateDepartureSlot := fmt.Sprintf(gateslotstemplate,
			departureGateOpenTimeString,
			departureSTOString,
			fmt.Sprintf("%s%d", gateArea.Area, gateNum),
			fmt.Sprintf("%s%d", gateArea.Area, gateNum),
			standArea.Area)

		gateArrivalSlot := fmt.Sprintf(gateslotstemplate,
			arrivalSTOString,
			arrGateCloseTimeString,
			fmt.Sprintf("%s%d", gateArea.Area, gateNum),
			fmt.Sprintf("%s%d", gateArea.Area, gateNum),
			standArea.Area)

		carouselSlot := fmt.Sprintf(carouselslotstemplate,
			arrivalSTOString,
			arrivalCarouselCloseTimeString,
			fmt.Sprintf("%s%d", carouselArea.Area, carouselNum),
			fmt.Sprintf("%s%d", gateArea.Area, carouselNum),
			carouselArea.Area)

		depmsg := fmt.Sprintf(depFlightUpdateBody,
			al,
			departureFlightNumber,
			departureSDOString,
			testConfig.TestConfig.Repository.AMSAirport,
			departureSTOString,
			al,
			arrivalFlightNumber,
			arrivalSDOString,
			testConfig.TestConfig.Repository.AMSAirport,
			arrivalSTOString,
			324174+i,
			registration,
			route,
			234174+i,
			standslot,
			gateDepartureSlot,
			checkinslot)

		arrmsg := fmt.Sprintf(arrFlightUpdateBody,
			al,
			arrivalFlightNumber,
			arrivalSDOString,
			testConfig.TestConfig.Repository.AMSAirport,
			arrivalSTOString,
			al,
			departureFlightNumber,
			departureSDOString,
			testConfig.TestConfig.Repository.AMSAirport,
			departureSTOString,
			234174+i,
			registration,
			route,
			324174+i,
			standslot,
			gateArrivalSlot,
			carouselSlot)

		if globals.DemoMode {
			// In demo mode, send the message to the processor directly
			//			fmt.Printf("DEMO MODE Posting test arrival flight %s%d\n", al, arrivalFlightNumber)
			fmt.Printf("A")
			if (i+1)%80 == 0 {
				fmt.Printf("[%d]\n", i+1)
			}
			UpdateFlightEntry(arrmsg, true)
			//			fmt.Printf("DEMO MODE Posting test departure flight %s%d\n", al, departureFlightNumber)
			fmt.Printf("D")
			if (i+2)%80 == 0 {
				fmt.Printf("[%d]\n", i+2)
			}
			UpdateFlightEntry(depmsg, true)

		} else {
			// In performance test mode, go via Rabbit MQ
			// In demo mode, send the message to the processor directly
			//			fmt.Printf("DEMO MODE Posting test arrival flight %s%d\n", al, arrivalFlightNumber)
			fmt.Printf("A")
			if i%80 == 0 && i != 0 {
				fmt.Printf("[%d]\n", i)
			}
			publishtopic(arrmsg)
			//			fmt.Printf("DEMO MODE Posting test departure flight %s%d\n", al, departureFlightNumber)
			fmt.Printf("D")
			if (i+1)%80 == 0 {
				fmt.Printf("[%d]\n", i+1)
			}
			publishtopic(depmsg)
		}
	}
	if nf%80 != 0 {
		fmt.Printf("[%d]\n", nf)
	}
	fmt.Println("Flights loaded. Ready to process requests via HTTP RestAPI")
}

func failOnError(err error, msg string) {
	if err != nil {
		log.Panicf("%s: %s", msg, err)
	}
}

func rmq() {
	conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/")
	failOnError(err, "Failed to connect to RabbitMQ")
	defer conn.Close()

	ch, err := conn.Channel()
	failOnError(err, "Failed to open a channel")
	defer ch.Close()

	q, err := ch.QueueDeclare(
		"hello", // name
		false,   // durable
		false,   // delete when unused
		false,   // exclusive
		false,   // no-wait
		nil,     // arguments
	)
	failOnError(err, "Failed to declare a queue")
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	body := "Hello World!"
	err = ch.PublishWithContext(ctx,
		"",     // exchange
		q.Name, // routing key
		false,  // mandatory
		false,  // immediate
		amqp.Publishing{
			ContentType: "text/plain",
			Body:        []byte(body),
		})
	failOnError(err, "Failed to publish a message")
	log.Printf(" [x] Sent %s\n", body)
}

func publishtopic(message string) {
	conn, err := amqp.Dial("amqp://amsauh:amsauh@localhost:5672/amsauh")
	failOnError(err, "Failed to connect to RabbitMQ")
	defer conn.Close()

	ch, err := conn.Channel()
	failOnError(err, "Failed to open a channel")
	defer ch.Close()

	err = ch.ExchangeDeclare(
		testConfig.TestConfig.Repository.RabbitMQExchange, // name
		"topic", // type
		true,    // durable
		false,   // auto-deleted
		false,   // internal
		false,   // no-wait
		nil,     // arguments
	)
	failOnError(err, "Failed to declare an exchange")

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	err = ch.PublishWithContext(ctx,
		testConfig.TestConfig.Repository.RabbitMQExchange, // exchange
		testConfig.TestConfig.Repository.RabbitMQTopic,    // routing key
		false, // mandatory
		false, // immediate
		amqp.Publishing{
			ContentType: "text/plain",
			Body:        []byte(message),
		})
	failOnError(err, "Failed to publish a message")
}

func bodyFrom(args []string) string {
	var s string
	if (len(args) < 3) || os.Args[2] == "" {
		s = "hello"
	} else {
		s = strings.Join(args[2:], " ")
	}
	return s
}

func severityFrom(args []string) string {
	var s string
	if (len(args) < 2) || os.Args[1] == "" {
		s = "anonymous.info"
	} else {
		s = os.Args[1]
	}
	return s
}
